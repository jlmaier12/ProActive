---
title: "ProActive"
author: "Jessie Maier"
output: 
  BiocStyle::html_document:
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{ProActiveVignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo=FALSE, warning=FALSE}
library(ProActive)
library(kableExtra)
library(ggplot2)
```

# Introduction
ProActive uses a pattern-matching algorithm to detect elevations and gaps in mapped sequencing read coverages. 
Read coverage patterns can have biological significance and recently, more attention has been drawn to the importance
of inspecting read coverages when analyzing your data (ref). 

Elevations in read coverage can be an indication of highly
active and/or abundant mobile genetic elements (MGEs). MGEs that are actively replicating or are highly abundant 
will generate more sequencing reads than the rest of their host 
bacterium's chromosome. This may create a region of elevated read coverage at 
the element's insertion site(s) in the genome. Examples  

Gaps in read coverage can indicate heterogeneity of the bacterial genome sequence. Genetic deletions and/or MGEs im subpopulations of bacteria may form gaps or dips in mapped read coverages. 

Despite the importance of read coverage , a limitation of tools requires that researchers manually inspect read coverages, a process which is time-consuming and therefor unrealistic in many cases. 
ProActive can operate on both metagenomes and genomes. A gff file with open reading frames (ORFs)


# Installation
## BioConductor install
```{r, eval=FALSE}
if (!require("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager")
}

BiocManager::install("ProActive")
library(ProActive)
```

## GitHub install
```{r, eval=FALSE}
if (!require("devtools", quietly = TRUE)) {
    install.packages("devtools")
}

devtools::install_github("jlmaier12/ProActive")
library(ProActive)
```

# Input data

##pileups

ProActive detects read coverage patterns using a pattern-matching algorithm that 
operates on pileup files. A pileup file is a file format where each row 
summarizes the 'pileup' of reads at specific genomic locations. Pileup files 
can be used to generate a rolling mean of read coverages and associated base 
pair positions which reduces data size while 
preserving read coverage patterns. **ProActive requires that input pileups files 
be generated using a 100 bp window/bin size.**  

Pileup files can be generated by either mapping sequencing reads to either a metagenome or genome fasta. **Read** 
**mapping should be performed using a high minimum identity (0.97 or higher)** 
**and random mapping of ambiguous reads.** The pileup files needed for ProActive 
are generated using the .bam files produced during read mapping. 

Some read mappers, like 
[BBMap](https://jgi.doe.gov/data-and-tools/software-tools/bbtools/bb-tools-user-guide/bbmap-guide/), 
will allow for the generation of pileup files in the 
[`bbmap.sh`](https://github.com/BioInfoTools/BBMap/blob/master/sh/bbmap.sh) 
command with the use of the `bincov` output with the `covbinsize=100` 
parameter/argument. **Otherwise, BBMap's** 
**[`pileup.sh`](https://github.com/BioInfoTools/BBMap/blob/master/sh/pileup.sh)** 
**can convert .bam files produced by any read mapper to pileup files** 
**compatible with ProActive using the `bincov` output with `binsize=100`.**

**The input pileup file must have the following format:**
**Pileup file must use a 100 bp window/bin size for the rolling** 
**mean.** 

Dataframe with four columns:

* V1: Contig accession
* V2: Mapped read coverage values averaged over 100 bp windows
* V3: Starting position (bp) of each 100 bp window. Restarts from 0 at the 
start of each new contig.
* V4: Starting position (bp) of each 100 bp window. Does NOT restart at the 
start of each new contig.

```{r echo=FALSE}
data(sampleMetagenomePileup)
kable(head(sampleMetagenomePileup), row.names = FALSE) %>%
    kable_styling(latex_options = "HOLD_position")
```

## gff TSV
ProActive optionally accepts a .gff file as input. The .gff file must be associated with the same metagenome or genome used to create your pileup file. The .gff file should be a TSV and should follow the same general format described [here](https://en.wikipedia.org/wiki/General_feature_format#:~:text=In%20bioinformatics%2C%20the%20general%20feature,DNA%2C%20RNA%20and%20protein%20sequences.)

**The input .gff file must have the following format:**
```{r echo=FALSE}
data(sampleMetagenomegffTSV)
kable(head(sampleMetagenomegffTSV), row.names = FALSE) %>%
    kable_styling(latex_options = "HOLD_position")
```


# ProActive()
`ProActive()` is the main function in the ProActive R package. This function filters 
contigs/chunks based on length and read coverage, performs pattern-matching to detect gaps and elevations in read coverage, identifies start and stop positions and sizes of pattern-matches, and determines pattern-match quality.    

**We recommend using IGV to further inspect read coverage patterns of interest. Viewing read mapping at a single nucleotide level can provide essential information regarding the nature of the elevation or gap in read coverage (i.e. sequencing artifact or real biology).**

## Function components

### Chunking
`ProActive()` can currently detect only one read coverage pattern per contig. While in many cases, contigs only have one read coverage pattern, the longer the contig is, the greater the chance that it has multiple read coverage patterns. Until ProActive is able to detect multiple read coverage patterns per contig, we rely on 'chunking' the contig into smaller subsets so that pattern-matching can be performed on each chunk as if it were an individual contig. 

### Filtering
Contigs that are too short or have little to no read coverage are filtered out 
prior to pattern-matching. `ProActive()` filters out contigs that do 
not have at least 10x coverage on a total of 5,000 bp across the whole contig. 
The read coverage filtering was done in this way to avoid filtering out long 
contigs with small elevations in read coverage that might get removed if filtering 
was done with read coverage averages or medians. Additionally, contigs less 
than 30,000 bp are filtered out by default, however this can be changed with 
the `minContigLength` parameter which can be set to a minimum of 25,000 bp. 
**If you would like to reduce the size of your input pileup files for** 
**ProActive, consider pre-filtering your assembly for contigs greater than** 
**25,000 bp prior to read mapping!** 

### Changing pileup windowSize
The input pileup files have 100 bp windows in which the mapped read coverage is 
averaged over. This small window size may be helpful to detect very small regions of elevated or gapped read coverage (bp), however in many cases, read coverage patterns don't require the resolution that 100 bp windows provide. While users can use the 100 bp `windowSize` for `ProActive()`, the processing time will be increased **significantly** and noisy data may 
interfere with pattern-matching. We find that the default 1,000 bp `windowSize` 
provides a nice balance between processing time and read coverage pattern 
resolution.  

### Pattern-matching
`ProActive()` detects read coverage patterns using 
a pattern-matching approach. Several predefined patterns, described below, are 
built using the specific length and read coverage values of the contig/chunk being 
assessed. Patterns are translated across each contig in 1,000 bp sliding 
windows and at each translation, a pattern-match score is calculated by taking 
the mean absolute difference of the read coverage and the pattern 
values. The smaller the match-score, the better the pattern-match. After a 
pattern is fully translated across a contig, certain aspects of the pattern are 
changed (i.e. height, base, width) and translation is repeated. This process 
of translation and pattern re-scaling is repeated until a large number of 
pattern variations are tested. After pattern-matching is complete, the pattern 
associated with the best match-score is used for contig/chunk classification. Contigs/chunks 
are classified as ‘Elevation’, ‘Gap’, or 'NoPattern' during 
pattern-matching. 

#### **Patterns**

##### Elevation:

The 'elevation' class is defined by a 'block' pattern which represents an elevated block of read coverage formed when the reads of mobilized genetic elements map back to their respective integration sites in the host bacterium's chromosome. During pattern-matching, both the heights (maxs), bases (mins) and widths of block patterns are altered and all pattern variations are translated across the contig. The block pattern widths never get smaller than 10,000 bp by default, however this can be changed with the `minBlockSize` parameter. 

```{r echo=FALSE, fig.width=4,fig.height=2}
dataframe <- cbind.data.frame(c(1:100), c(rep(0, 20), rep(100, 60), rep(0, 20)))
colnames(dataframe) <- c("mockpos", "mockcov")
plot1 <- ggplot(dataframe, aes(x = mockpos, y = mockcov)) +
    geom_line(linewidth = 1) +
    labs(x = NULL, y = NULL, title = "Pattern 1") +
    theme_classic() +
    ggplot2::theme(
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        plot.title = element_text(size = 10),
        panel.border = element_rect(colour = "black", fill = NA, linewidth = 2)
    )

plot1
```


##### Gap:



```{r echo=FALSE, fig.width=4,fig.height=2}
dataframe <- cbind.data.frame(c(1:100), c(rep(100, 20), rep(5, 60), rep(100, 20)))
colnames(dataframe) <- c("mockpos", "mockcov")
plot1 <- ggplot(dataframe, aes(x = mockpos, y = mockcov)) +
    geom_line(linewidth = 1) +
    labs(x = NULL, y = NULL, title = "Pattern 1") +
    theme_classic() +
    ggplot2::theme(
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        plot.title = element_text(size = 10),
        panel.border = element_rect(colour = "black", fill = NA, linewidth = 2)
    )

plot1
```

##### Elevations/Gaps:



```{r echo=FALSE, fig.width=4,fig.height=2}
dataframe <- cbind.data.frame(c(1:100), c(rep(100, 50), rep(5, 50)))
colnames(dataframe) <- c("mockpos", "mockcov")
plot1 <- ggplot(dataframe, aes(x = mockpos, y = mockcov)) +
    geom_line(linewidth = 1) +
    labs(x = NULL, y = NULL, title = "Pattern 1") +
    theme_classic() +
    ggplot2::theme(
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        plot.title = element_text(size = 10),
        panel.border = element_rect(colour = "black", fill = NA, linewidth = 2)
    )

plot1
```

##### noPattern:
Since the best pattern-match for each contig/chunk is determined by comparing 
match-scores amongst all pattern-variations from all pattern classes, we needed 
a ‘negative control’ pattern to compare against. The 'NoPattern' 'pattern' 
serves as a negative control by matching to contigs/chunks with no read coverage 
patterns. We made two NoPattern patterns which consist of a horizontal line the 
same length as the contig being assessed at either the average or median read 
coverage for a contig. This pattern is not re-scaled or translated in any way. 

```{r echo=FALSE, fig.width=4,fig.height=2}
dataframe <- cbind.data.frame(c(1:100), rep(10, 100))
colnames(dataframe) <- c("mockpos", "mockcov")
plot1 <- ggplot(dataframe, aes(x = mockpos, y = mockcov)) +
    geom_line(linewidth = 1) +
    ylim(0, 100) +
    labs(x = NULL, y = NULL, title = "Pattern 1") +
    theme_classic() +
    ggplot2::theme(
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        plot.title = element_text(size = 10),
        panel.border = element_rect(colour = "black", fill = NA, linewidth = 2)
    )
plot1
```

### Determining quality of pattern-matches



### Detecting ORFs in elevated/gapped regions



## Usage

Default arguments:
```{r}
ProActiveOutput <- ProActive(pileup=sampleMetagenomePileup, 
                             mode="metagenome", 
                             gffTSV=sampleMetagenomegffTSV)
```
**Note that ProActive *can* be run without the gffTSV file!** 

## Arguments/parameters
```{r, eval=FALSE}
ProActive(pileup, 
          mode, 
          gffTSV, 
          windowSize = 1000, 
          minSize=10000, 
          maxSize=Inf, 
          minContigLength=30000, 
          chunkSize=50000,
          chunkContigs=FALSE,
          IncludeNoPatterns=FALSE, 
          saveFilesTo)
```

- `pileup`: A .txt file containing mapped sequencing read coverages averaged over 100 bp windows/bins.
- `mode`: Either "genome" or "metagenome" 
- `gffTSV`: Optional, a .gff file (TSV) containing ORFs associated with the fasta file used to generate the pileup. 
- `windowSize`: The number of basepairs to average read coverage values over. 
Options are 100, 200, 500, 1000 ONLY.  Default is 1000.
- `minSize`: The minimum size (in bp) of elevation or gap patterns. Default is 10000.
- `maxSize`: The maximum size (in bp) of elevation or gap patterns. Default is NA (i.e. no maximum).
- `minContigLength`: The minimum contig/chunk size (in bp) to perform pattern-matching on. Default is 25000.
- `chunkSize`: If `mode`="genome" OR if `mode`="metagenome" and `chunkContigs`=TRUE, chunk the genome or contigs, respectively, into smaller subsets for pattern-matching. `chunkSize` determines the size (in bp) of each 'chunk'. Default is 50000.
- `chunkContigs`: TRUE or FALSE, If TRUE and `mode`="metagenome", contigs longer than the `chunkSize` will be 'chunked' into smaller subsets and pattern-matching will be performed on each subset. Default is FALSE.
- `IncludeNoPatterns`: TRUE or FALSE, If TRUE the noPattern pattern-matches will be included in the ProActive PatternMatches output list. If you would like to visualize the noPattern pattern-matches in `plotProActiveResults()`, this should be set to TRUE. 
- `saveFilesTo`: Optional, Provide a path to the directory you wish to save 
output to. A folder will be made within the provided directory to store 
results.


## Output

The output of `ProActive` is a list containing 4 objects:

1. ORFTable:
2. SummaryTable:
3. PatternMatches:
4. FilteredOut:
5. Arguments:

Save the desired list-item to a new variable using its associated name.

ORF Table:
```{r}
ProActiveORFTable <- ProActiveOutput$ORFTable
```

```{r, echo=FALSE}
kable(head(ProActiveORFTable)) %>%
    kable_styling(latex_options = "HOLD_position")
```

Summary table:
```{r}
ProActiveSummaryTable <- ProActiveOutput$SummaryTable
```

```{r, echo=FALSE}
kable(ProActiveSummaryTable) %>%
    kable_styling(latex_options = "HOLD_position")
```


# plotProActiveResults()

`plotProActiveResults()` allows users to visualize both the read coverage and 
the pattern-match associated with each gap or elevation in read coverage.

## Function components

### Re-building pattern-matches
The `ProActive()` output contains information needed to re-build each 
pattern-match used for classification. To re-build a complete 
pattern-match for visualization, `plotProActiveResults()` uses the 
pattern-match's minimum and maximum values and the start and stop positions.

### Plotting read coverage and associated pattern-matches
The read coverage is plotted for each contig or genome/contig chunk
classified as having a gap or elevation in read coverage. The pattern-match 
associated with the classification is overlaid on the read coverage.

## Usage

Default arguments:
```{r}
ProActivePlots <- plotProActiveResults(pileup=sampleMetagenomePileup, 
                                       ProActiveResults=ProActiveOutput)
```

## Arguments/parameters
```{r, eval=FALSE}
plotProActiveResults(pileup, 
                     ProActiveResults, 
                     qualityFilter=NA, 
                     elevFilter=NA, 
                     saveFilesTo) {
```

- `pileup`: A .txt file containing mapped sequencing read coverages averaged over 100 bp windows/bins.
- `ProActiveResults`: The output from `ProActive()`.
- `qualityFilter`: Optional, only plot results with pattern-matches that achieved a specified quality level. Options are "high", "okay", and "poor". Default is NA (i.e. no filter).
- `elevFilter`: Optional, only plot results with pattern-matches that achieved an elevation ratio (max/min) greater than the specified values. Defualt is NA (i.e. no filter).
- `saveFilesTo`: Optional, Provide a path to the directory you wish to save 
output to. A folder will be made within the provided directory to store 
results.

## Output

The output of `plotProActiveResults` is a list of ggplot objects. 

View all plots:
```{r}
ProActivePlots
```


# Session Information
```{r}
sessionInfo()
```

