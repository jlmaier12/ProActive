#' Highly active/abundant MGE prediction function
#'
#' The main function that ties together all the other functions. This function performs all the shape-matching and summarizes the results into a list. The first item in the list is a table consisting of the summary information of all the contigs that passed through shape-matching (i.e were not filtered out). The second item in the list is a table consisting of the summary information of all contigs that were predicted as containing a potential active prophage. The third item in the list contains the best shape-match information associated with each contig in the previous table. The fourth and final object in the list is a table containing the contigs that were filtered out prior to shape_matching and the reason why.
#'
#'@param pileup A pileup file for either a genome or metagenome containing mapped read coverages averaged over 100 bp window sizes
#'@param mode Either "genome" or "metagenome"
#'@param windowsize The number of base pairs to average coverage values over. For compatibility with shape-matching, window sizes can only be 200, 500, 1000 and 2000. Larger window sizes improve processing time but the resolution of read coverage patterns may be lost. 1000bp windowsize is the default.
#'@param minsize The minimum size of elevated read coverage that ProActive searches for. Default is 10000 base pairs.
#'@param maxsize The minimum size of elevated read coverage that ProActive searches for. Default is the close to the length of the contig being assessed.
#'@param chunksize If mode="genome", ProActive will split your genome into chunks to search for elevated read coverage. Since ProActive can only identify one elevated read coverage pattern per 'chunk', choosing smaller chunks will increase sensitivity AND processing time. Default is 100,000bp per chunk, with the exception of the last chunk which is the remainder number of base pairs once the genome has been evenly 'chunked'.
#'@param cleanup If pileup files are generated by BBMap's pileup.sh, the files output from pileup.sh can be input directly into ProActive with cleanup=TRUE. If your pileup files are NOT generated with BBMap's pileup.sh, set cleanup=FALSE. The user is responsible for data cleaning/formatting if this option is used.
#'@param nones TRUE or FALSE. Default is FALSE. TRUE if you would like to include the contigs classified as 'none' in your final pattern lists. This can be useful if you are comparing ProActive results between conditions.
#'@export
#'
#'@examples
#' \dontrun{
#'ProActive_results <- ProActive(pileup=whole_commreadcoverages, mode="metagenome", windowsize=1000, minsize=10000, maxsize=50000, cleanup=TRUE)
#'}
ProActive <- function(pileup, mode, windowsize = 1000, minsize=10000, maxsize=Inf, chunksize=100000, nones=TRUE, cleanup=FALSE){
  start_time <- Sys.time()
  if (cleanup==TRUE){
    pileup <- readcovdf_formatter(pileup, mode)
  }
  if(mode=="genome"){
    pileup <- GenomeChunks(pileup, chunksize)
  }
  cat("Starting shape-matching \n")
  SM_predictions_summary <- shape_matcher(pileup, windowsize, minsize, maxsize, mode)
  SM_conf_prophagepredictions_list <- SM_predictions_summary[[1]]
  SM_prophagepredictions_list <- SM_predictions_summary[[2]]
  SM_honmentions_list <- SM_predictions_summary[[3]]
  SM_none_predictions_list <- SM_predictions_summary[[4]]
  if ((nones=TRUE)==TRUE) {
    FullPredictionList <- c(SM_conf_prophagepredictions_list, SM_prophagepredictions_list, SM_honmentions_list, SM_none_predictions_list)
  } else if ((nones=TRUE)==FALSE){
    FullPredictionList <- c(SM_conf_prophagepredictions_list, SM_prophagepredictions_list, SM_honmentions_list)
  }
  filteredoutcontigs_df <- SM_predictions_summary[[5]]
  cat("Identifying potential active/abundant MGEs \n")
  Prediction_summary_df <- contig_prediction_summary(pileup, FullPredictionList, windowsize, mode)
  cat("Determining sizes (bp) of potential active/abundant MGEs \n")
  summary_table_matchsize <- matchsize_checker(Prediction_summary_df, FullPredictionList, windowsize)
  cat("Finalizing output \n")
  if ((nones=TRUE)==TRUE) {
    final_summary_list<-list(summary_table_matchsize, SM_conf_prophagepredictions_list, SM_prophagepredictions_list, SM_honmentions_list,  SM_none_predictions_list, filteredoutcontigs_df, windowsize, mode, chunksize)
    names(final_summary_list) <- c("SummaryTable", "VeryConfidentPatternMatches", "ConfidentPatternMatches", "NotConfidentPatternMatches", "NonePatternMatches","FilteredOut", "Windowsize", "Mode", "Chunksize")
    end_time <- Sys.time()
    cat(paste("Execuion time:", end_time-start_time, "\n"))
    cat(paste(length(SM_conf_prophagepredictions_list), "contigs with extra confident predictions", length(SM_prophagepredictions_list), "contigs with confident predictions", length(SM_honmentions_list), "contigs with okay predictions and"), length(SM_none_predictions_list), "with no elevations/gaps in read coverage")
    return(final_summary_list)
    }else if ((nones=TRUE)==FALSE){
    final_summary_list<-list(summary_table_matchsize, SM_conf_prophagepredictions_list, SM_prophagepredictions_list, SM_honmentions_list, filteredoutcontigs_df, windowsize, mode, chunksize)
    names(final_summary_list) <- c("SummaryTable", "VeryConfidentPatternMatches", "ConfidentPatternMatches", "NotConfidentPatternMatches", "FilteredOut", "Windowsize", "Mode", "Chunksize")
    end_time <- Sys.time()
    cat(paste("Execuion time:", end_time-start_time, "\n"))
    cat(paste(length(SM_conf_prophagepredictions_list), "contigs with extra confident predictions", length(SM_prophagepredictions_list), "contigs with confident predictions and", length(SM_honmentions_list), "contigs with okay predictions"))
    return(final_summary_list)
    }
}

